// Code generated by main. DO NOT EDIT.

package v1alpha1

import (
	"context"
	"sync"
	"time"

	v1alpha1 "github.com/alexandreLamarre/pprof-controller/pkg/operator/apis/v1alpha1"
	"github.com/rancher/wrangler/v3/pkg/apply"
	"github.com/rancher/wrangler/v3/pkg/condition"
	"github.com/rancher/wrangler/v3/pkg/generic"
	"github.com/rancher/wrangler/v3/pkg/kv"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// PprofMonitorController interface for managing PprofMonitor resources.
type PprofMonitorController interface {
	generic.ControllerInterface[*v1alpha1.PprofMonitor, *v1alpha1.PprofMonitorList]
}

// PprofMonitorClient interface for managing PprofMonitor resources in Kubernetes.
type PprofMonitorClient interface {
	generic.ClientInterface[*v1alpha1.PprofMonitor, *v1alpha1.PprofMonitorList]
}

// PprofMonitorCache interface for retrieving PprofMonitor resources in memory.
type PprofMonitorCache interface {
	generic.CacheInterface[*v1alpha1.PprofMonitor]
}

// PprofMonitorStatusHandler is executed for every added or modified PprofMonitor. Should return the new status to be updated
type PprofMonitorStatusHandler func(obj *v1alpha1.PprofMonitor, status v1alpha1.PprofStatus) (v1alpha1.PprofStatus, error)

// PprofMonitorGeneratingHandler is the top-level handler that is executed for every PprofMonitor event. It extends PprofMonitorStatusHandler by a returning a slice of child objects to be passed to apply.Apply
type PprofMonitorGeneratingHandler func(obj *v1alpha1.PprofMonitor, status v1alpha1.PprofStatus) ([]runtime.Object, v1alpha1.PprofStatus, error)

// RegisterPprofMonitorStatusHandler configures a PprofMonitorController to execute a PprofMonitorStatusHandler for every events observed.
// If a non-empty condition is provided, it will be updated in the status conditions for every handler execution
func RegisterPprofMonitorStatusHandler(ctx context.Context, controller PprofMonitorController, condition condition.Cond, name string, handler PprofMonitorStatusHandler) {
	statusHandler := &pprofMonitorStatusHandler{
		client:    controller,
		condition: condition,
		handler:   handler,
	}
	controller.AddGenericHandler(ctx, name, generic.FromObjectHandlerToHandler(statusHandler.sync))
}

// RegisterPprofMonitorGeneratingHandler configures a PprofMonitorController to execute a PprofMonitorGeneratingHandler for every events observed, passing the returned objects to the provided apply.Apply.
// If a non-empty condition is provided, it will be updated in the status conditions for every handler execution
func RegisterPprofMonitorGeneratingHandler(ctx context.Context, controller PprofMonitorController, apply apply.Apply,
	condition condition.Cond, name string, handler PprofMonitorGeneratingHandler, opts *generic.GeneratingHandlerOptions) {
	statusHandler := &pprofMonitorGeneratingHandler{
		PprofMonitorGeneratingHandler: handler,
		apply:                         apply,
		name:                          name,
		gvk:                           controller.GroupVersionKind(),
	}
	if opts != nil {
		statusHandler.opts = *opts
	}
	controller.OnChange(ctx, name, statusHandler.Remove)
	RegisterPprofMonitorStatusHandler(ctx, controller, condition, name, statusHandler.Handle)
}

type pprofMonitorStatusHandler struct {
	client    PprofMonitorClient
	condition condition.Cond
	handler   PprofMonitorStatusHandler
}

// sync is executed on every resource addition or modification. Executes the configured handlers and sends the updated status to the Kubernetes API
func (a *pprofMonitorStatusHandler) sync(key string, obj *v1alpha1.PprofMonitor) (*v1alpha1.PprofMonitor, error) {
	if obj == nil {
		return obj, nil
	}

	origStatus := obj.Status.DeepCopy()
	obj = obj.DeepCopy()
	newStatus, err := a.handler(obj, obj.Status)
	if err != nil {
		// Revert to old status on error
		newStatus = *origStatus.DeepCopy()
	}

	if a.condition != "" {
		if errors.IsConflict(err) {
			a.condition.SetError(&newStatus, "", nil)
		} else {
			a.condition.SetError(&newStatus, "", err)
		}
	}
	if !equality.Semantic.DeepEqual(origStatus, &newStatus) {
		if a.condition != "" {
			// Since status has changed, update the lastUpdatedTime
			a.condition.LastUpdated(&newStatus, time.Now().UTC().Format(time.RFC3339))
		}

		var newErr error
		obj.Status = newStatus
		newObj, newErr := a.client.UpdateStatus(obj)
		if err == nil {
			err = newErr
		}
		if newErr == nil {
			obj = newObj
		}
	}
	return obj, err
}

type pprofMonitorGeneratingHandler struct {
	PprofMonitorGeneratingHandler
	apply apply.Apply
	opts  generic.GeneratingHandlerOptions
	gvk   schema.GroupVersionKind
	name  string
	seen  sync.Map
}

// Remove handles the observed deletion of a resource, cascade deleting every associated resource previously applied
func (a *pprofMonitorGeneratingHandler) Remove(key string, obj *v1alpha1.PprofMonitor) (*v1alpha1.PprofMonitor, error) {
	if obj != nil {
		return obj, nil
	}

	obj = &v1alpha1.PprofMonitor{}
	obj.Namespace, obj.Name = kv.RSplit(key, "/")
	obj.SetGroupVersionKind(a.gvk)

	if a.opts.UniqueApplyForResourceVersion {
		a.seen.Delete(key)
	}

	return nil, generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects()
}

// Handle executes the configured PprofMonitorGeneratingHandler and pass the resulting objects to apply.Apply, finally returning the new status of the resource
func (a *pprofMonitorGeneratingHandler) Handle(obj *v1alpha1.PprofMonitor, status v1alpha1.PprofStatus) (v1alpha1.PprofStatus, error) {
	if !obj.DeletionTimestamp.IsZero() {
		return status, nil
	}

	objs, newStatus, err := a.PprofMonitorGeneratingHandler(obj, status)
	if err != nil {
		return newStatus, err
	}
	if !a.isNewResourceVersion(obj) {
		return newStatus, nil
	}

	err = generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects(objs...)
	if err != nil {
		return newStatus, err
	}
	a.storeResourceVersion(obj)
	return newStatus, nil
}

// isNewResourceVersion detects if a specific resource version was already successfully processed.
// Only used if UniqueApplyForResourceVersion is set in generic.GeneratingHandlerOptions
func (a *pprofMonitorGeneratingHandler) isNewResourceVersion(obj *v1alpha1.PprofMonitor) bool {
	if !a.opts.UniqueApplyForResourceVersion {
		return true
	}

	// Apply once per resource version
	key := obj.Namespace + "/" + obj.Name
	previous, ok := a.seen.Load(key)
	return !ok || previous != obj.ResourceVersion
}

// storeResourceVersion keeps track of the latest resource version of an object for which Apply was executed
// Only used if UniqueApplyForResourceVersion is set in generic.GeneratingHandlerOptions
func (a *pprofMonitorGeneratingHandler) storeResourceVersion(obj *v1alpha1.PprofMonitor) {
	if !a.opts.UniqueApplyForResourceVersion {
		return
	}

	key := obj.Namespace + "/" + obj.Name
	a.seen.Store(key, obj.ResourceVersion)
}
